#include <Arduino.h>
#include <SPI.h>
#include <MFRC522.h>
#include <PubSubClient.h>
#include <internet.h>
#include <WiFi.h>
#include <ArduinoJson.h>
// Pinos conectados ao RC522
#define SS_PIN 5   // SDA do RC522
#define RST_PIN 22 // RST do RC522

MFRC522 rfid(SS_PIN, RST_PIN); // cria o objeto do leitor
WiFiClient espClient;
PubSubClient client(espClient);

const char *mqtt_server = "broker.hivemq.com";
const int mqtt_port = 1883;
const char *mqtt_id = "esp32-senai225-Henrique";
const char *mqtt_topic_sub = "senai134/mesaDiller/esp_inscrito";
const char *mqtt_topic_pub = "senai134/mesaJogador/esp_publicando";

void limitFragments();
void amountFragments();
void drawPhase();
void callback(char *, byte *, unsigned int);
void mqttConnect(void);
// TODO : Adicionar a parte do Curupira, a funcao de eliminar cartas(nao sei se e no esp do diller ou do jogador) e adicionar o MQTT

struct Values
{
  int fragment = 6;            // Variável para armazenar a quantidade de fragmentos do Elo
  const int boto = 3;          // Valor da carta Boto
  const int saci = -3;         // Valor da carta Saci
  const int curupira = -2;     // Valor da carta Curupira
  const int maxfragments = 10; // Valor máximo de fragmentos que o jogador pode ter
};
Values value; // Cria uma instância da estrutura Values

struct CardsState
{
  bool Boto = false;     // Variável para armazenar o estado da carta boto cor de rosa
  bool Saci = false;     // Variável para armazenar o estado da carta saci
  bool Curupira = false; // Variável para armazenar o estado da carta curupira
};
CardsState cards; // Cria uma instância da estrutura cards

struct playerState
{
  bool draw = false;     // Variável para armazenar o estado da compra
  //bool endturn = false; // Variável para armazenar o estado do turno (provavelmente pro diller)
  bool ritual = false;  // Variável para armazenar o estado da carta golpe de estado
};
playerState player; // Cria uma instância da estrutura player

void setup()
{
  Serial.begin(9600);
  SPI.begin();     // Inicia SPI com GPIOs padrão do ESP32
  rfid.PCD_Init(); // Inicia o RC522
  delay(1000);
  Serial.println("Aproxime um cartão RFID...");
  conectaWiFi(); // Conecta ao WiFi
  client.setServer(mqtt_server, mqtt_port);// Define o servidor MQTT e a porta
  client.setCallback(callback); // Define a função de callback para receber mensagens MQTT
}

void loop()
{

  if (!rfid.PICC_IsNewCardPresent())
    return;
  if (!rfid.PICC_ReadCardSerial())
    return;

  checkWiFi(); // Verifica a conexão WiFi
  mqttConnect(); // Conecta ao MQTT se não estiver conectado
  client.loop(); // Mantém o loop do cliente MQTT ativo
  //* Parte do Boto
  if (cards.Boto)
  {
    if (value.fragment < value.maxfragments) // Se a carta for Boto e moedas forem menores que 10
    {
      Serial.println("Carta Boto ativada! Você ganhou 3 moedas");
      value.fragment += value.boto; // Adiciona o valor da carta Boto
      delay(50);
      amountFragments(); // Chama a função para mostrar a quantidade de fragmentos
    }
    if (value.fragment > value.maxfragments) // Garante que não ultrapasse o máximo
    {
      limitFragments();
    }

    cards.Boto = false; // Reseta o estado da carta Boto
  }
  //* Parte do Saci
  if (cards.Saci)
  {
    if (value.fragment >= 3)
    {
      value.fragment += value.saci; // Subtrai o valor da carta Saci

      // todo : Adicionar funcao para eliminar uma carta do jogo

      Serial.println("Carta Saci ativada! Você gastou 3 fragmentos para eliminar uma carta.");
      Serial.print("Quantidade de fragmentos: ");
      Serial.println(value.fragment);
    }
    else
    {
      Serial.println("Você não tem fragmentos suficientes para usar a carta Saci.");
      Serial.print("Quantidade de fragmentos: ");
      Serial.println(value.fragment);
    }
    cards.Saci = false; // Reseta o estado da carta Saci
  }

  //* Parte da Draw(Compra de cartas)

  if (player.draw)
  {
    Serial.println("Você pode comprar uma carta. Pressione o botão para comprar.");
    drawPhase(); // Chama a função de compra de cartas
  }

  else
  {
    Serial.println("Você ja comprou um fragmento.");
    Serial.print("Quantidade de fragmentos: ");
    Serial.println(value.fragment);
  }
  // if (player.endturn) // Se o turno terminar
  // {
  //   player.draw = true; // Reseta o estado da compra
  //   Serial.println("Turno encerrado. Pronto para o próximo jogador.");
  // }

  //* Parte do Ritual do Esquecimento (Golpe de Estado)

  if (value.fragment >= 7 && player.ritual == true) // Se tiver pelo menos 7 fragmentos
  {
    // colocar opcao de iniciar o ritual no (provavelmente um botao) LCD
    value.fragment -= 7;   // Gasta 7 fragmentos
    player.ritual = false; // Reseta o estado do ritual
    Serial.println("Ritual do Esquecimento ativado! Você eliminou uma carta do jogo.");
    Serial.print("Quantidade de fragmentos restantes: ");
    Serial.println(value.fragment);

    // Mandar mensagem para o dealer resetando as cartas do jogador afetado pelo ritual
  }

  //* Parte do Curupira

  if (cards.Curupira)
  {
    if (value.fragment >= 2) // Se a carta for Curupira e moedas forem maiores que 2
    {
      value.fragment += value.curupira; // Subtrai o valor da carta Curupira
      Serial.println("Carta Curupira ativada! Você perdeu 2 fragmentos.");
      amountFragments(); // Chama a função para mostrar a quantidade de fragmentos
    }
    else
    {
      Serial.println("Você não tem fragmentos suficientes para usar a carta Curupira.");
      amountFragments(); // Chama a função para mostrar a quantidade de fragmentos
    }
    cards.Curupira = false; // Reseta o estado da carta Curupira
  }

  delay(2000);
}

void limitFragments()
{
  if (value.fragment > value.maxfragments) // Garante que não ultrapasse o máximo
  {
    value.fragment = value.maxfragments; // Reseta as moedas para 10 se exceder o limite
    Serial.println("Você atingiu o máximo de fragmentos. Use o Ritual do Esquecimento para eliminar uma carta.");
  }
}

void amountFragments()
{
  Serial.print("Quantidade de fragmentos: ");
  Serial.println(value.fragment); // Mostra a quantidade de moedas após a compra
}

void drawPhase()
{

  value.fragment += 1; // Adiciona 1 fragmento ao total
  Serial.println("Você coletou um Fragmento do Elo");
  Serial.print("Quantidade de fragmentos restantes: ");
  if (value.fragment > 10)
  {
    limitFragments(); // Chama a função para limitar os fragmentos
  }

  player.draw = false;
}

void callback(char *topic, byte *payload, unsigned int length)
{
  //Serial.printf("Mensagem recebida em %s: ", topic);

  String mensagem = "";
  for (unsigned int i = 0; i < length; i++)
  {
    char c = (char)payload[i];
    mensagem += c;
  }

  mensagem.trim();
  mensagem.toLowerCase();

  //Serial.println(mensagem);

  if (mensagem == "boto")
  {
    cards.Boto = true; // Ativa a carta Boto
    //Serial.println("Carta Boto ativada!");
  }
  else if (mensagem == "saci")
  {
    cards.Saci = true; // Ativa a carta Saci
    //Serial.println("Carta Saci ativada!");
  }
  else if (mensagem == "curupira")
  {
    cards.Curupira = true; // Ativa a carta Curupira
    //Serial.println("Carta Curupira ativada!");
  }
  else if (mensagem == "ritual")
  {
    player.ritual = true; // Ativa o ritual do esquecimento
    //Serial.println("Ritual do Esquecimento ativado!");
  }
}
void mqttConnect()
{
  while (!client.connected())
  {
    Serial.println("Conectando ao MQTT...");

    if (client.connect(mqtt_id))
    {
      Serial.println("Conectado com sucesso");
      client.subscribe(mqtt_topic_sub);
    }
    else
    {
      Serial.print("Falha, rc=");
      Serial.println(client.state());
      Serial.println("Tentando novamente em 5 segundos");
      delay(5000);
    }
  }
}




//! Comentado pois provavelmente ira para o diller

/* Parte do Diller (não implementada)
if (player.endturn) // Se o turno terminar
  {
    player.draw = true; // Reseta o estado da compra
    Serial.println("Turno encerrado. Pronto para o próximo jogador.");
  }
  if (fragment==maxfragments) // Se tiver 10 fragmentos e o ritual não estiver ativo
  {
    Serial.println("Você atingiu o máximo de fragmentos.o Ritual do Esquecimento sera ativado para eliminar uma carta.");
    player.ritual = true; // Ativa o ritual
  }
  */
