#include <ArduinoJson.h>
#include <Arduino.h>
#include <SPI.h>
#include <WiFi.h>
#include <internet.h>
#include <PubSubClient.h>

#define MaxPlayers 4 // Define o número máximo de jogadores
#define MaxCards 3   // Define o número máximo de cada carta

WiFiClient espClient;
PubSubClient client(espClient);

struct Game
{
  bool gameStarted = false;  // Variável para armazenar o estado do jogo
  bool gamecardBoto = false; // Variável para armazenar o estado da carta Boto
  bool gamecardSaci = false; // Variável para armazenar o estado da carta Saci
  bool gamecardIara = false; // Variável para armazenar o estado da carta Iara
};
Game game;

struct Players
{
  bool Endturn = false;   // Variável para armazenar o estado do turno do jogador
  bool HandCards = false; // Variável para armazenar o estado das cartas na mão do jogador
  bool Ready = false;     //
};

Players player[MaxPlayers]; // Cria um array de jogadores com o tamanho máximo definido

int playersCount = 0; // Variável para armazenar o número de jogadores

const char *mqtt_server = "broker.hivemq.com";
const int mqtt_port = 1883;
const char *mqtt_id = "esp32-senai225-Henrique";

String mqtt_topic_subs[MaxPlayers];
String mqtt_topic_pubs[MaxPlayers];

void callback(char *, byte *, unsigned int);
void mqttConnect(void);
void handCards(void);
void checkPlayers(void);

void setup()
{
  Serial.begin(9600);

  conectaWiFi();                            // Conecta ao WiFi
  client.setServer(mqtt_server, mqtt_port); // Define o servidor MQTT e a porta
  client.setCallback(callback);             // Define a função de callback para receber mensagens MQTT
  for (int i = 0; i < MaxPlayers; i++)
  {
    mqtt_topic_subs[i] = String("senai134/Jogador") + (i + 1) + "/esp_inscrito";   // Define os tópicos de inscrição para cada jogador
    mqtt_topic_pubs[i] = String("senai134/Jogador") + (i + 1) + "/esp_publicando"; // Define os tópicos de publicação para cada jogador
  }
}

void loop()

{
  mqttConnect();  // Conecta ao MQTT
  checkWiFi();    // Verifica a conexão WiFi
  client.loop();  // Mantém o loop do cliente MQTT ativo
  checkPlayers(); // Verifica o número de jogadores e inicia o jogo se necessário
  handCards();    // Verifica se o jogador pode comprar cartas e ativa as cartas correspondentes
}

void callback(char *topic, byte *payload, unsigned int length)
{

  String mensagem = "";
  for (unsigned int i = 0; i < length; i++)
  {
    char c = (char)payload[i];
    mensagem += c;
  }

  mensagem.trim();
  mensagem.toLowerCase();

  for (int i = 0; i < MaxPlayers; i++) // Verifica se a mensagem é de algum dos tópicos de inscrição
  {
    if (String(topic) == mqtt_topic_subs[i])
    {
      if (!player[i].Ready)
      {
        player[i].Ready = true;
      }
      if (mensagem == "pronto" && player[i].Ready)
      {
        playersCount++; // Incrementa o número de jogadores quando recebe a mensagem "ready"
        Serial.print("Jogadores prontos: ");
        Serial.println(i + 1);
      }
      else
      {
        Serial.println("Erro na contagem de jogadores");
      }
    }
  }
}
void mqttConnect()
{
  while (!client.connected())
  {
    Serial.println("Conectando ao MQTT...");

    if (client.connect(mqtt_id))
    {
      Serial.println("Conectado com sucesso");
      for (int i = 0; i < MaxPlayers; i++)
      {
        client.subscribe(mqtt_topic_subs[i].c_str());
      }
    }
    else
    {
      Serial.print("Falha, rc=");
      Serial.println(client.state());
      Serial.println("Tentando novamente em 5 segundos");
      delay(5000);
    }
  }
}

void checkPlayers()
{
  unsigned long tempoEspera = millis();        // Variável para armazenar o tempo de espera
  static unsigned long tempoUltimaConexao = 0; // Variável para armazenar o tempo da última conexão WiFi

  if (playersCount >= 2 && !game.gameStarted)
  {
    Serial.println("Numero de jogadores suficiente, iniciando o jogo...");
    game.gameStarted = true;

    for (int i = 0; i < playersCount; i++)
    {
      player[i].HandCards = true;
    }
  }
  else if (playersCount < 2)
  {

    {
      Serial.println("Aguardando mais jogadores");
      delay(3000);
    }
  }
}

void cardsDistribution()
{
  
randomSeed(1);
  if (playersCount < 2) return;

  const int cardsAmount = 3;
  int cardsAvailable[cardsAmount] = {3, 3, 3};
  int playersCards[playersCount][2];

  for (int i = 0; i < playersCount; i++)
  {
    for (int j = 0; j < 2; j++)
    {
      int cardsToGive;
      do
      {
        int cardToGive = random(0, cardsAmount);
      } while (cardsAvailable[cardsToGive] <= 0);

      playersCards[i][j] = cardsToGive;
      cardsAvailable[cardsToGive]--;
    }
  }
}
